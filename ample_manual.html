<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="/Users/eric/.pandoc/theme_a.css">
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <style>
  @font-face {
    font-family: 'Open Sans';
    font-style: normal;
    font-weight: 300;
    src: local('Open Sans Light'), local('OpenSans-Light'), url(http://themes.googleusercontent.com/static/fonts/opensans/v8/DXI1ORHCpsQm3Vp6mXoaTaRDOzjiPcYnFooOUGCOsRk.woff) format('woff');
  }
  @font-face {
    font-family: 'Open Sans';
    font-style: normal;
    font-weight: 400;
    src: local('Open Sans'), local('OpenSans'), url(http://themes.googleusercontent.com/static/fonts/opensans/v8/cJZKeOuBrn4kERxqtaUH3bO3LdcAZYWl9Si6vvxL-qU.woff) format('woff');
  }
  @font-face {
    font-family: 'Open Sans';
    font-style: normal;
    font-weight: 600;
    src: local('Open Sans Semibold'), local('OpenSans-Semibold'), url(http://themes.googleusercontent.com/static/fonts/opensans/v8/MTP_ySUJH_bn48VBG8sNSqRDOzjiPcYnFooOUGCOsRk.woff) format('woff');
  }
  @font-face {
    font-family: 'Open Sans';
    font-style: normal;
    font-weight: 700;
    src: local('Open Sans Bold'), local('OpenSans-Bold'), url(http://themes.googleusercontent.com/static/fonts/opensans/v8/k3k702ZOKiLJc3WVjuplzKRDOzjiPcYnFooOUGCOsRk.woff) format('woff');
  }
  @font-face {
    font-family: 'Open Sans';
    font-style: normal;
    font-weight: 800;
    src: local('Open Sans Extrabold'), local('OpenSans-Extrabold'), url(http://themes.googleusercontent.com/static/fonts/opensans/v8/EInbV5DfGHOiMmvb1Xr-hqRDOzjiPcYnFooOUGCOsRk.woff) format('woff');
  }
  
  /* Set Fonts */
  p {font-family: "open sans";}
  h1{font-family: "open sans";}
  h2{font-family: "open sans"; border-bottom: 1px solid #000000;}
  h3{font-family: "open sans"; border-bottom: 1px solid #dddddd;}
  h4{font-family: "open sans";}
  li{font-family: "open sans";}
  ul{font-family: "open sans";}
  a {font-family: "open sans";}
  td{font-family: "open sans";}
  th{font-family: "open sans";}
  
  /*TOC*/
  nav TOC {
    border: 1px solid #999;
  }
  
  
  /* Tables */
  table{
    border-collapse: collapse;
    margin-left: auto;
    margin-right: auto;
  }
  td, th{
    border: 1px solid #999;
    padding: 0.5rem;
    text-align: left;
  }
  
  th{
    background: #dddddd;
  }
  
  
  /* Syntax Highlighting */
  pre {
    padding: 1em;
    margin: 0;
    background-color: #403635;
    /*border: 1px solid #b5db99;*/
    color: #ffffff;
    border-radius: 2px;
    box-shadow: 0px 0px 20px #999999;
  }
  
  p code, ul code, h1 code, h2 code, h3 code, li code, td code{
    background-color: #dddddd;
    /*border: 1px solid #999999;*/
    border-radius: 2px;
    padding: 2px 2px 2px 2px;
  }
  
  /*// KeyWordTok*/
  code > span.kw { color: #ff9787; }
  /*// DataTypeTok*/
  code > span.dt { color: #FF9787; }
  
  /*// DecValTok (decimal value), BaseNTok, FloatTok*/
  /*code > span.dv, code > span.bn, code > span.fl { color: #FF9787; }*/
  /*// CharTok*/
  code > span.ch { color: #ff9787; }
  /*// StringTok*/
  code > span.st { color: #b5db99; }
  /*// CommentTok*/
  code > span.co { color: #c3b8b7; }
  /*// OtherTok*/
  /*.sourceCode .ot { color: #e9c865; }*/
  /*// AlertTok*/
  /*.sourceCode .al { color: #CB4B16; font-weight: bold; }*/
  /*// FunctionTok*/
  code > span.fu { color: #b5db99; }
  /*// RegionMarkerTok*/
  /*.sourceCode .re { }*/
  /*// ErrorTok*/
  /*.sourceCode .er { color: #D30102; font-weight: bold; }*/
  </style>
</head>
<body>
<nav id="TOC">
<ul>
<li><a href="#ample-manual">Ample Manual</a><ul>
<li><a href="#usage">Usage</a></li>
<li><a href="#ample-system-format">Ample-System Format</a><ul>
<li><a href="#explicit">Explicit</a></li>
<li><a href="#functional">Functional</a></li>
</ul></li>
<li><a href="#prior-modules">Prior Modules</a><ul>
<li><a href="#module-format">Module Format</a></li>
<li><a href="#included-modules">Included Modules</a></li>
</ul></li>
<li><a href="#table-of-options-default-values">Table of Options &amp; Default Values</a><ul>
<li><a href="#option-descriptions">Option Descriptions</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="ample-manual">Ample Manual</h1>
<h2 id="usage">Usage</h2>
<p><code>ample</code> can be called from Matlab using the following command.</p>
<pre class="sourceCode matlab"><code class="sourceCode matlab">[a,c] = ample(A,y,priorHandle,<span class="st">&#39;Option1&#39;</span>,Value1,<span class="st">&#39;Option2&#39;</span>,Value2, ...);</code></pre>
<ul>
<li><code>y</code> is the set of observations.</li>
<li><code>A</code> is the system used to obtain <code>y</code> from the unknown signal. This system must be in the <code>ample-system</code> format, which will be described below.</li>
<li><code>priorHandle</code> is a function handle which takes two inputs, the hidden variables <span class="math">\(\left\{R,\Sigma\right\}\)</span>.</li>
<li><code>&lt;options&gt;</code> is a Matlab-style list of varargin options in the pairs of <code>'opt_name',opt_value</code>.</li>
</ul>
<p>The <code>demos</code> directory contains a number of useful examples for different signal priors and <code>ample</code> option modes. The best place to start is with <code>demos/ample_gb_demo.m</code>.</p>
<h2 id="ample-system-format">Ample-System Format</h2>
<p>In order to find the factorized probabilities, <code>ample</code> needs to know the system which generated the observations, <code>y</code>. This information is given by the variable <code>A</code> in the description in the previous section. <code>ample</code> will operate on two different methods of specifying <code>A</code>:</p>
<h3 id="explicit">Explicit</h3>
<p>In this mode, <code>A</code> is assumed to be a linear system which is defined by an <code>MxN</code> matrix where <code>y</code> is of dimensionality <code>M</code> and the observed signals are of dimensionality <code>x</code>. I.e. a set of observations of a given signal is given by <span class="math">\(y = A x\)</span>.</p>
<h3 id="functional">Functional</h3>
<p>This is a more general mode for defining the observational model of <code>A</code>. Here, both linear and non-linear observations can be constructed. Instead of an explicit matrix defining a linear system, in functional mode, the variable <code>A</code> is given as a structure with four fields, each of which is a function handle of a single vector input to produce each of the following four operations...</p>
<ul>
<li><code>A.forward</code>: Computes the forward (signal-&gt;observation) mapping.</li>
<li><code>A.adjoint</code>: Computes the adjoint (observation-&gt;kernel-space) mapping.</li>
<li><code>A.squared_forward</code>: The squared operation is particular to the AMP algorithm. For a linear system, the squared forward mapping is equivalent to <span class="math">\[ (A \circ A)~x, \]</span> where <span class="math">\(\circ\)</span> is the element-wise, or Hadamaard, product.</li>
<li><code>A.squared_adjoint</code>: The squared adjoint is similar to the above, but for the adjoint operation. For a linear system, this would be equivalent to <span class="math">\[ (A \circ A)^T~y.\]</span></li>
</ul>
<p>Here is an example of a random linear system using this format.</p>
<pre class="sourceCode matlab"><code class="sourceCode matlab">N    = <span class="fl">128</span>;                        <span class="co">% Signal dimensionality</span>
M    = <span class="fl">64</span>;                         <span class="co">% Number of observations</span>
x    = randn(N,<span class="fl">1</span>);                 <span class="co">% Random signal</span>
Phi  = randn(M,N) ./ sqrt(N);      <span class="co">% Random system</span>
PhiT = Phi&#39;;                       <span class="co">% Defining the adjoint</span>
Phi2 = Phi.*Phi;                   <span class="co">% Defining the squared forward</span>
Phi2T= Phi2&#39;;                      <span class="co">% Defining the squared adjoint</span>

A.forward         = @(x_) Phi  *x_;
A.adjoint         = @(y_) PhiT *y_;
A.squared_forward = @(x_) Phi2 *x_;
A.squared_adjoint = @(y_) Phi2T*y_;

y = A.forward(x);
z = A.adjoint(y);</code></pre>
<h2 id="prior-modules">Prior Modules</h2>
<p>One of the nice aspects of the AMP framework is its applicability to a wide range of possible signal priors. With the right approach, even non-iid (i.e. structured) signal priors can even be used to great effect with AMP. The <code>ample</code> package provides this same versatility to the user by modularizing prior-specific calculations. The prior modules follow a standard format.</p>
<h3 id="module-format">Module Format</h3>
<p>The prior modules must follow the same general format.</p>
<pre class="sourceCode matlab"><code class="sourceCode matlab">function [a,c,learned_params] = prior_module(r,s,params)
    <span class="co">% Must return new learned prior parameters if requested</span>
    learn_prior = <span class="fl">0</span>;
    if nargout &gt; <span class="fl">2</span>
        learn_prior = <span class="fl">1</span>;
    end

    <span class="co">% 1. Calculate factorized means of variational distribution, `a`.</span>
    <span class="co">% 2. Calculate factorized means of variational distribution, `c`.</span>
    if learn_prior
        <span class="co">% 3. If new learned parameters are requested, update accordingly</span>
    end</code></pre>
<p>Here, the values <code>r</code> and <code>s</code> are the AMP hidden variables for the means and variances associated with the variational Gaussian. The structure of the <code>params</code> variable is entirely up to the module writer, <code>ample</code> will support both vector-valued and cell-valued <code>params</code>.</p>
<blockquote>
<p><strong>Important Note:</strong> If <code>params</code> is specified as a cell variable, then <code>params{1}</code> <em>must</em> contain the vector of learned variables !</p>
</blockquote>
<p>The module writer must be familiar with the calculation of the means and variances of the variational form of their desired prior distribution, <span class="math">\[a_i = \left&lt; x_i \right&gt; = \frac{1}{Z} \int \text{d}x 
~~x~P_0(x;\theta) \exp\left\{ \frac{(x - R_i)^2}{2 \Sigma_i^2}\right\},\]</span></p>
<p><span class="math">\[c_i = \left&lt; x_i^2 \right&gt; - a_i^2= \frac{1}{Z} \int \text{d}x 
~~x^2~P_0(x;\theta) \exp\left\{ \frac{(x - R_i)^2}{2 \Sigma_i^2}\right\},\]</span></p>
<p>where <span class="math">\(P_0\)</span> is the desired prior distribution and <span class="math">\(\theta\)</span> are the parameters associated with that distribution. This will generally also include the calculation of the proper partition function. Depending on the prior, this calculation may be extremly non-trivial. If numerical integration is required to solve for these variables, <code>ample</code> will still support this, but at the cost computation time.</p>
<p>The determination of the prior parameter update may be equally non-trivial, in general.</p>
<h3 id="included-modules">Included Modules</h3>
<p>For ease of use, some common prior modules are already included in the <code>ample</code> package. These serve as good examples for the expected format of the prior modules. <code>ample</code> currently provides the following signal priors:</p>
<ul>
<li><strong>Binary</strong>
<ul>
<li><code>priors/prior_binary.m</code></li>
<li>Signal coefficients are discrete values are in <span class="math">\(\left\{ 0, 1\right\}\)</span> and have value <span class="math">\(1\)</span> with probability <span class="math">\(\rho\)</span>.</li>
<li><code>params</code> format:
<ul>
<li><code>params(1)</code> -- <span class="math">\(\rho\)</span></li>
</ul></li>
</ul></li>
<li><strong>Gauss-Bernoulli </strong>
<ul>
<li><code>priors/prior_gb.m</code></li>
<li>Signal coefficients are real values given by <span class="math">\[Prob[x_i = x] \propto (1 - \rho)~\delta(x) + \rho \mathcal{N}(\mu,\sigma^2).\]</span> This distribution has been shown to be very good for modelling &quot;sparse&quot; signals, such as those desired for compressed sensing.</li>
<li><code>params</code> format:
<ul>
<li><code>params(1)</code> -- <span class="math">\(\mu\)</span></li>
<li><code>params(2)</code> -- <span class="math">\(\sigma^2\)</span></li>
<li><code>params(3)</code> -- <span class="math">\(\rho\)</span></li>
</ul></li>
</ul></li>
<li><strong>L1-Sparse</strong>
<ul>
<li><code>priors/prior_l1sparse.m</code></li>
<li>Signal coefficients are assumed to be sparse, or at least compressible. That is, there are assumed to be very few non-zero coefficients. Using the L1-Sparse module isn't neccesarily defining a &quot;prior,&quot; per-se, but it does solve the equivalent LASSO problem when using <code>ample</code> for inverse-problems such as compressed sensing, <span class="math">\[ a = \arg \min_x || x ||_1 ~~ \text{s.t.} ~~ || y - A x ||^2_2 &lt; \epsilon\]</span></li>
<li><code>params</code> format:
<ul>
<li><code>params(1)</code> -- Minimum coefficient value</li>
<li><code>params(2)</code> -- Maximum coefficient value</li>
</ul></li>
</ul></li>
<li><strong>Q-ary</strong>
<ul>
<li><code>priors/prior_qary.m</code></li>
<li>Signal coefficients are discrete values in <span class="math">\(\left\{ \tau_0, \tau_1, \dots, \tau_{Q-1} \right\}\)</span> with probabilities defined according to the PMF <span class="math">\[ Prob[x = \tau_q] = \rho_q. \]</span></li>
<li><code>params</code> format:
<ul>
<li><code>params{1}</code> -- PMF vector, <span class="math">\(\left[\rho_0, \rho_1, \dots, \rho_{Q-1}\right]\)</span></li>
<li><code>params{2}</code> -- Alphabet vector, <span class="math">\(\left[\tau_0,\tau_1,\dots,\tau_{Q-1} \right]\)</span></li>
</ul></li>
</ul></li>
</ul>
<h2 id="table-of-options-default-values">Table of Options &amp; Default Values</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Option Name</th>
<th style="text-align: left;">Values</th>
<th style="text-align: center;">Default Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>convergence_tolerance</code></td>
<td style="text-align: left;">Positive Small Real</td>
<td style="text-align: center;"><code>1e-10</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>convergence_type</code></td>
<td style="text-align: left;">{<code>'residual'</code>,<code>'iteration'</code>}</td>
<td style="text-align: center;"><code>'iteration'</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>damp</code></td>
<td style="text-align: left;">Real in [0,1)</td>
<td style="text-align: center;">0.0</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>debug</code></td>
<td style="text-align: left;">Boolean</td>
<td style="text-align: center;"><code>false</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>delta</code></td>
<td style="text-align: left;">Positive Real</td>
<td style="text-align: center;">1.0</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>image_mode</code></td>
<td style="text-align: left;">Boolean</td>
<td style="text-align: center;"><code>false</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>init_a</code></td>
<td style="text-align: left;">Vector of reals</td>
<td style="text-align: center;"><code>zeros(N,1)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>init_c</code></td>
<td style="text-align: left;">Vector of positive reals</td>
<td style="text-align: center;"><code>ones(N,1)</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>learn_delta</code></td>
<td style="text-align: left;">Boolean</td>
<td style="text-align: center;"><code>true</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>learning_mode</code></td>
<td style="text-align: left;">{<code>'track'</code>,<code>'em'</code>}</td>
<td style="text-align: center;"><code>'track'</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>learn_prior_params</code></td>
<td style="text-align: left;">Boolean</td>
<td style="text-align: center;"><code>false</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>max_em_iterations</code></td>
<td style="text-align: left;">Positive Integer</td>
<td style="text-align: center;">20</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>max_iterations</code></td>
<td style="text-align: left;">Positive Integer</td>
<td style="text-align: center;">250</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>pause_mode</code></td>
<td style="text-align: left;">Boolean</td>
<td style="text-align: center;"><code>false</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>prior_damp</code></td>
<td style="text-align: left;">Real in [0,1)</td>
<td style="text-align: center;">0.0</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>prior_params</code></td>
<td style="text-align: left;">Function Handle</td>
<td style="text-align: center;"><em>See</em> 'Prior Modules'</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>report_history</code></td>
<td style="text-align: left;">Boolean</td>
<td style="text-align: center;"><code>true</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>true_solution</code></td>
<td style="text-align: left;">Vector of Reals</td>
<td style="text-align: center;"><code>[]</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>verbose_mode</code></td>
<td style="text-align: left;">{0,1}</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<h3 id="option-descriptions">Option Descriptions</h3>
<h4 id="required">Required</h4>
<ul>
<li><code>prior_params</code>: A vector or cell structure which specifies needed parameters for the chosen prior module. See the &quot;Prior Modules&quot; section for more information.</li>
</ul>
<h4 id="general">General</h4>
<ul>
<li><code>convergence_tolerance</code>: Tolerance for between-iteration differences. The way in which this difference is calculated is dependent upon the setting of convergence type.</li>
<li><code>convergence_type</code>: Specifies how to measure between-iteration convergence.
<ul>
<li><code>'iteration'</code>: Measures the mean-square-error (MSE) between the values of <code>a</code> at each iteration, <span class="math">\[ \frac{1}{N} \left|\left| a^{k} - a^{k-1} \right|\right|^2_2.\]</span></li>
<li><code>'residual'</code>: Measures the squared <span class="math">\(\ell_2\)</span> difference between the given observations <code>y</code> and the current iteration, <span class="math">\[ \left|\left| y - A(a^{k}) \right|\right|^2_2.\]</span></li>
</ul></li>
<li><code>max_iterations</code>: Prevents <code>ample</code> from continuing in an oscillatory state indefinitely. Specify the maximum number of iterations AMP iterations to perform.</li>
<li><code>verbose_mode</code>: Controls the level of reporting to the console.
<ul>
<li><code>0</code>: Print nothing to console.</li>
<li><code>1</code>: Print per-iteration information.</li>
</ul></li>
<li><code>delta</code>: The variance of the AWGN on the measurements. Since it is a variance, should have a positive value. If the noise variance is unknown, then this value will be used as the <em>initialization</em> for estimation of the noise variance. In this case, it is best to start this value high, i.e. <code>1</code> as in the default case.</li>
</ul>
<h4 id="debug">Debug</h4>
<ul>
<li><code>true_solution</code>: Vector of the originally sampled signal. Useful to track the progress of the AMP iteration.</li>
<li><code>debug</code>: Useful mode when testing out new prior modules. When running in debug mode, per-iteration state information will be printed to a number of figures so that the user can track the progress of AMP.</li>
<li><code>pause_mode</code>: Pauses <code>ample</code> after each AMP iteration. Useful in the <code>debug = 1</code> setting to view the per-iteration outputs.</li>
<li><code>image_mode</code>: If the original signal was an image, it is helpful to reshape the per-iteration state information back into two dimensional format for viewing in debug mode. This option does nothing if not currently running in debug mode.</li>
<li><code>report_history</code>: Controls whether or not the per-iteration history for the algorithm is recorded in the output history variable or not. This is useful if one wants to turn off history reporting when more than 2 output arguments are specified. In this case, it is the default operation of <code>ample</code> to record this history information. This setting can disable that recording.</li>
</ul>
<h4 id="fine-tuning">Fine-Tuning</h4>
<ul>
<li><code>init_a</code>: Initial value for the factorized means. The dimensionality of <code>init_a</code> should be equal to that of the original signal.</li>
<li><code>init_c</code>: Initial value for the factorized variances.The dimensionality of <code>init_c</code> should be equal to that of the original signal.</li>
<li><code>damp</code>: Sets a damping-value, <span class="math">\(\alpha\)</span>, on the update of <span class="math">\(\left\{ R, \Sigma\right\}\)</span> at each iteration, <span class="math">\[R^{k} = \alpha R^{k-1} + (1 - \alpha) \mathcal{F}(a^{k-1},c^{k-1}),\]</span> <span class="math">\[\Sigma^{k} = \alpha \Sigma^{k-1} + (1 - \alpha) \mathcal{G}(a^{k-1},c^{k-1}),\]</span> where <span class="math">\(\mathcal{F}\)</span> and <span class="math">\(\mathcal{G}\)</span> are the calculations for the variational Gaussian's means and variances, respectively.</li>
<li><code>prior_damp</code>: Sets a damping-value, <span class="math">\(\gamma\)</span>, on the update of <span class="math">\(\left\{a,c\right\}\)</span> at each iteration,<span class="math">\[a^{k} = \gamma a^{k-1} + (1 - \gamma) \mathcal{I}(R^{k},\Sigma^{k}),\]</span> <span class="math">\[c^{k} = \gamma c^{k-1} + (1 - \gamma) \mathcal{J}(R^{k},\Sigma^{k}),\]</span> where <span class="math">\(\mathcal{I}\)</span> and <span class="math">\(\mathcal{J}\)</span> are the calculations for the factorized means and variances, respectively, which are dependent upon the prior module. This damping is only useful in some corner cases.</li>
</ul>
<h4 id="learning-control">Learning Control</h4>
<ul>
<li><code>learn_delta</code>: Controls whether or not the value of the noise variance will be estimated alongside the factorization.</li>
<li><code>learn_prior_params</code>: Controls whether or not the value of the prior parameters will be estimated alongside the factorization. The manner in which these parameters are estimated is controlled by the prior module. For more information, see the &quot;Prior Modules&quot; section.</li>
<li><code>learning_mode</code>: Specify when estimated variables are updated.
<ul>
<li><code>'em'</code>: All learned parameters are updated <em>after</em> the convergence of the AMP iteration, i.e. when <span class="math">\(\left\{a,c,R,\Sigma \right\}\)</span> are all at their fixed-point values. This mode can be much slower than the <code>'track'</code> mode since it requires multiple AMP convergences.</li>
<li><code>'track'</code>: All learned parameters are updated at each AMP iteration using non-converged values of <span class="math">\(\left\{a,c,R,\Sigma \right\}\)</span>.</li>
</ul></li>
<li><code>max_em_iterations</code>: When running <code>learning_mode = 'em'</code>, this option controls the maximum number of AMP convergences (and therefore, the maximum number of learned parameter updates).</li>
</ul>
</body>
</html>
