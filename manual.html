<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
MathJax.Hub.Config({
  config: ["MMLorHTML.js"],
  extensions: ["tex2jax.js"],
  jax: ["input/TeX"],
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    processEscapes: false
  },
  TeX: {
    extensions: ["AMSmath.js", "AMSsymbols.js"],
    TagSide: "right",
    TagIndent: ".8em",
    MultLineWidth: "85%",
    equationNumbers: {
      autoNumber: "AMS",
    },
    unicode: {
      fonts: "STIXGeneral,'Arial Unicode MS'"
    }
  },
  showProcessingMessages: false
});
</script>


    <title>Ample by eric-tramel</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Ample</h1>
        <h2>Approximate Message Passing for Everyone</h2>
        <a href="https://github.com/eric-tramel/ample" class="button"><small>View project on</small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1>
<a name="ample" class="anchor" href="#ample"><span class="octicon octicon-link"></span></a>ample</h1>





    <h2 id="usage">Usage</h2>
<p><code>ample</code> can be called from Matlab using the following command.</p>
<pre><code>[a,c] = ample(A,y,priorHandle,&lt;options&gt;);
</code></pre>

<ul>
<li><code>y</code> is the set of observations.</li>
<li><code>A</code> is the system used to obtain <code>y</code> from the unknown signal. This
  system must be in the <code>ample-system</code> format, which will be described
  below.</li>
<li><code>priorHandle</code> is a function handle which takes two inputs, the hidden
  variables $\left\{R,\Sigma\right\}$.</li>
<li><code>&lt;options&gt;</code> is a Matlab-style list of varargin options
in the pairs of <code>'opt_name',opt_value</code>.</li>
</ul>
<p>The <code>demos</code> directory contains a number of useful examples for different
signal priors and <code>ample</code> option modes. The best place to start is with
<code>demos/ample_gb_demo.m</code>.</p>
<h3 id="ample-system-format">Ample-System Format</h3>
<p>In order to find the factorized probabilities, <code>ample</code> needs to know the 
system which generated the observations, <code>y</code>. This information is given
by the variable <code>A</code> in the description in the previous section. <code>ample</code> 
will operate on two different methods of specifying <code>A</code>: </p>
<h4 id="explicit">Explicit</h4>
<p>In this mode, <code>A</code> is assumed to be a linear system which is defined by an <code>MxN</code> matrix where <code>y</code> is of dimensionality <code>M</code> and the observed signals are of dimensionality <code>x</code>. I.e. a set of observations of a given signal is given by <code>y = A x</code>.</p>
<h4 id="functional">Functional</h4>
<p>This is a more general mode for defining the observational model of <code>A</code>. Here, both linear and non-linear observations can be constructed. Instead of an explicit matrix defining a linear system, in functional mode, the variable <code>A</code> is given as a structure with four fields, each of which is a function handle
of a single vector input to produce each of the following four operations...</p>
<ul>
<li><code>A.forward</code>: Computes the forward (signal-&gt;observation) mapping. </li>
<li><code>A.adjoint</code>: Computes the adjoint (observation-&gt;kernel-space) mapping.</li>
<li><code>A.squared_forward</code>: The squared operation is particular to the AMP algorithm. For a linear system, the squared forward mapping is equivalent to $$ (A \circ A)~x, $$ where $\circ$ is the element-wise, or Hadamaard, product.</li>
<li><code>A.squared_adjoint</code>: The squared adjoint is similar to the above, but for the adjoint operation. For a linear system, this would be equivalent to $$ (A \circ A)^T~y.$$.</li>
</ul>
<p>Here is an example of a random linear system using this format.</p>
<pre><code>N    = 128;                        % Signal dimensionality
M    = 64;                         % Number of observations
x    = randn(N,1);                 % Random signal
Phi  = randn(M,N) ./ sqrt(N);      % Random system
PhiT = Phi';                       % Defining the adjoint
Phi2 = Phi.*Phi;                   % Defining the squared forward
Phi2T= Phi2';                      % Defining the squared adjoint

A.forward         = @(x_) Phi  *x_;
A.adjoint         = @(y_) PhiT *y_;
A.squared_forward = @(x_) Phi2 *x_;
A.squared_adjoint = @(y_) Phi2T*y_;

y = A.forward(x);
z = A.adjoint(y);
</code></pre>

<h3 id="prior-modules">Prior Modules</h3>
<p>One of the nice aspects of the AMP framework is its applicability to a 
wide range of possible signal priors. With the right approach, even 
non-iid (i.e. structured) signal priors can even be used to great effect
with AMP. The <code>ample</code> package provides this same versatility to the user
by modularizing prior-specific calculations. The prior modules follow a 
standard format.</p>
<h4 id="module-format">Module Format</h4>
<p>The prior modules must follow the same general format.</p>
<pre><code>function [a,c,learned_params] = prior_module(r,s,params)
    % Must return new learned prior parameters if requested
    learn_prior = 0;
    if nargout &gt; 2
        learn_prior = 1;
    end

    % 1. Calculate factorized means of variational distribution, `a`.
    % 2. Calculate factorized means of variational distribution, `c`.
    if learn_prior
        % 3. If new learned parameters are requested, update accordingly
    end
</code></pre>

<p>Here, the values <code>r</code> and <code>s</code> are the AMP hidden variables for the means
and variances associated with the variational Gaussian. The structure of 
the <code>params</code> variable is entirely up to the module writer, <code>ample</code> will
support both vector-valued and cell-valued <code>params</code>. </p>
<blockquote>
<p><strong>Important Note:</strong>  If <code>params</code> is specified as a cell variable, then 
<code>params{1}</code> <em>must</em> contain the vector of learned variables !</p>
</blockquote>
<p>The module writer must be familiar with the calculation of the means and
variances of the variational form of their desired prior distribution,
$$a_i = \left&lt; x_i \right&gt; = \frac{1}{Z} \int \text{d}x 
~~x~P_0(x;\theta) \exp\left\{ \frac{(x - R_i)^2}{2 \Sigma_i^2}\right\},$$</p>
<p>$$c_i = \left&lt; x_i^2 \right&gt; - a_i^2= \frac{1}{Z} \int \text{d}x 
~~x^2~P_0(x;\theta) \exp\left\{ \frac{(x - R_i)^2}{2 \Sigma_i^2}\right\},$$</p>
<p>where $P_0$ is the desired prior distribution and $\theta$ are the parameters
associated with that distribution. This will generally also include the calculation of the proper partition function. Depending on the prior, this calculation may be extremly non-trivial. If numerical integration is required to solve for these variables, <code>ample</code> will still support this, but at the cost computation time. </p>
<p>The determination of the prior parameter update may be equally non-trivial,
in general.</p>
<h4 id="included-modules">Included Modules</h4>
<p>For ease of use, some common prior modules are already included in the
<code>ample</code> package. These serve as good examples for the expected format
of the prior modules. <code>ample</code> currently provides the following signal 
priors:</p>
<ul>
<li><strong>Binary</strong> <ul>
<li><code>priors/prior_binary.m</code></li>
<li>Signal coefficients are discrete values are in $\left\{ 0, 1\right\}$ and have value $1$ with probability $\rho$.</li>
<li><code>params</code> format:<ul>
<li><code>params(1)</code> --  $\rho$ </li>
</ul>
</li>
</ul>
</li>
<li><strong>Gauss-Bernoulli </strong><ul>
<li><code>priors/prior_gb.m</code></li>
<li>Signal coefficients are real values given by $$Prob[x_i = x] \propto (1 - \rho)~\delta(x) + \rho \mathcal{N}(\mu,\sigma^2).$$ This distribution has been shown to be very good for modelling "sparse" signals, such as those desired for compressed sensing.</li>
<li><code>params</code> format:<ul>
<li><code>params(1)</code> --  $\mu$ </li>
<li><code>params(2)</code> --  $\sigma^2$</li>
<li><code>params(3)</code> --  $\rho$</li>
</ul>
</li>
</ul>
</li>
<li><strong>L1-Sparse</strong><ul>
<li><code>priors/prior_l1sparse.m</code></li>
<li>Signal coefficients are assumed to be sparse, or at least compressible. That is, there are assumed to be very few non-zero coefficients. Using the L1-Sparse module isn't neccesarily defining a "prior," per-se, but it does solve the equivalent LASSO problem when using <code>ample</code> for inverse-problems such as compressed sensing, $$ a = \arg \min_x || x ||_1 ~~ \text{s.t.} ~~ || y - A x ||^2_2 &lt; \epsilon$$</li>
<li><code>params</code> format:<ul>
<li><code>params(1)</code> -- Minimum coefficient value</li>
<li><code>params(2)</code> -- Maximum coefficient value</li>
</ul>
</li>
</ul>
</li>
<li><strong>Q-ary</strong><ul>
<li><code>priors/prior_qary.m</code></li>
<li>Signal coefficients are discrete values in $\left\{ \tau_0, \tau_1, \dots, \tau_{Q-1} \right\}$ with probabilities defined according to the PMF $$ Prob[x = \tau_q] = \rho_q. $$</li>
<li><code>params</code> format:<ul>
<li><code>params{1}</code> -- PMF vector, $\left[\rho_0, \rho_1, \dots, \rho_{Q-1}\right]$</li>
<li><code>params{2}</code> -- Alphabet vector, $\left[\tau_0,\tau_1,\dots,\tau_{Q-1} \right]$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="table-of-options-default-values">Table of Options &amp; Default Values</h3>
<table>
<thead>
<tr>
<th align="left">Option Name</th>
<th>Values</th>
<th align="center">Default Value</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>convergence_tolerance</code></td>
<td>Positive Small Real</td>
<td align="center"><code>1e-10</code></td>
</tr>
<tr>
<td align="left"><code>convergence_type</code></td>
<td>{<code>'residual'</code>,<code>'iteration'</code>}</td>
<td align="center"><code>'iteration'</code></td>
</tr>
<tr>
<td align="left"><code>damp</code></td>
<td>Real in [0,1)</td>
<td align="center">0.0</td>
</tr>
<tr>
<td align="left"><code>debug</code></td>
<td>Boolean</td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="left"><code>delta</code></td>
<td>Positive Real</td>
<td align="center">1.0</td>
</tr>
<tr>
<td align="left"><code>image_mode</code></td>
<td>Boolean</td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="left"><code>init_a</code></td>
<td>Vector of reals</td>
<td align="center"><code>zeros(N,1)</code></td>
</tr>
<tr>
<td align="left"><code>init_c</code></td>
<td>Vector of positive reals</td>
<td align="center"><code>ones(N,1)</code></td>
</tr>
<tr>
<td align="left"><code>learn_delta</code></td>
<td>Boolean</td>
<td align="center"><code>true</code></td>
</tr>
<tr>
<td align="left"><code>learning_mode</code></td>
<td>{<code>'track'</code>,<code>'em'</code>}</td>
<td align="center"><code>'track'</code></td>
</tr>
<tr>
<td align="left"><code>learn_prior_params</code></td>
<td>Boolean</td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="left"><code>max_em_iterations</code></td>
<td>Positive Integer</td>
<td align="center">20</td>
</tr>
<tr>
<td align="left"><code>max_iterations</code></td>
<td>Positive Integer</td>
<td align="center">250</td>
</tr>
<tr>
<td align="left"><code>mean_approximation</code></td>
<td>Boolean</td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="left"><code>pause_mode</code></td>
<td>Boolean</td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="left"><code>prior_damp</code></td>
<td>Real in [0,1)</td>
<td align="center">0.0</td>
</tr>
<tr>
<td align="left"><code>prior_params</code></td>
<td>Function Handle</td>
<td align="center"><em>See</em> 'Prior-Handle Format'</td>
</tr>
<tr>
<td align="left"><code>report_history</code></td>
<td>Boolean</td>
<td align="center"><code>true</code></td>
</tr>
<tr>
<td align="left"><code>true_solution</code></td>
<td>Vector of Reals</td>
<td align="center"><code>[]</code></td>
</tr>
<tr>
<td align="left"><code>verbose_mode</code></td>
<td>{0,1}</td>
<td align="center">1</td>
</tr>
</tbody>
</table>
<h4 id="option-descriptions">Option Descriptions</h4>
<h5 id="required">Required</h5>
<ul>
<li><code>prior_params</code>:</li>
</ul>
<h5 id="general">General</h5>
<ul>
<li><code>convergence_tolerance</code>:</li>
<li><code>convergence_type</code>:</li>
<li><code>max_iterations</code>:</li>
<li><code>verbose_mode</code>:</li>
<li><code>delta</code>:</li>
</ul>
<h5 id="debug">Debug</h5>
<ul>
<li><code>true_solution</code>:</li>
<li><code>debug</code>:</li>
<li><code>pause_mode</code>:</li>
<li><code>image_mode</code>:</li>
<li><code>report_history</code>:</li>
</ul>
<h5 id="fine-tuning">Fine-Tuning</h5>
<ul>
<li><code>init_a</code>: Initial value for the factorized means. The dimensionality of <code>init_a</code> should be equal to that of the original signal.</li>
<li>
<p><code>init_c</code>: Initial value for the factorized variances.The dimensionality of <code>init_c</code> should be equal to that of the original signal.</p>
</li>
<li>
<p><code>damp</code>:</p>
</li>
<li><code>prior_damp</code>: </li>
</ul>
<h5 id="learning-control">Learning Control</h5>
<ul>
<li><code>learn_delta</code>:</li>
<li><code>learn_prior_params</code>:</li>
<li><code>learning_mode</code>:</li>
<li><code>max_em_iterations</code>:</li>
</ul>







        </section>

        <aside id="sidebar">
          <a href="https://github.com/eric-tramel/ample/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/eric-tramel/ample/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/eric-tramel/ample"></a> is maintained by <a href="https://github.com/eric-tramel">eric-tramel</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>
